<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

<script>
    // JS 基本数据类型
    // number string object boolean undefined null Symbol
    /*
        Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。
        可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。
    */
    let yellow = Symbol('yellow');
    let yellow2 = Symbol('yellow');
    console.log(yellow == yellow2); //=>false

    /**
        Set 对象
        Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

        Set 中的特殊值
        Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

        +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
        undefined 与 undefined 是恒等的，所以不重复；
        NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。
    */
    let set = new Set();
    set.add('1');
    set.add('1');
    console.log(set); //=> Set [ "1" ]
    console.log(typeof set) //=>object

    let mySet = new Set();
    mySet.add(1); // Set(1) {1}
    mySet.add(5); // Set(2) {1, 5}
    mySet.add(5); // Set(2) {1, 5} 这里体现了值的唯一性
    mySet.add("some text");
    // Set(3) {1, 5, "some text"} 这里体现了类型的多样性
    var o = {
        a: 1,
        b: 2
    };
    mySet.add(o);
    mySet.add({
        a: 1,
        b: 2
    });
    console.log(mySet);
    // Set(5) {1, 5, "some text", {…}, {…}} 
    // 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储

    //Array 转 Set
    let arr = [1, 2, 3, 4, 5, 6, 1, 2, "value1", "value2", "value3", 4, 6]
    let set2 = new Set(arr);
    console.log(set2);
    //set 转 Array
    let arr2 = [...set2];
    console.log(arr2);

    //Set 对象的作用
    // 数组去重
    var _set = new Set([1, 2, 3, 4, 4]);
    [..._set]; // [1, 2, 3, 4]

    // 并集
    var a = new Set([1, 2, 3]);
    var b = new Set([4, 3, 2]);
    var union = new Set([...a, ...b]); // {1, 2, 3, 4}
    console.log(union);

    // 交集
    var a = new Set([1, 2, 3]);
    var b = new Set([4, 3, 2]);
    var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3}
    console.log(intersect)

    // 差集
    var a = new Set([1, 2, 3]);
    var b = new Set([4, 3, 2]);
    var difference = new Set([...a].filter(x => !b.has(x))); // {1}
    console.log(difference)
</script>

</html>